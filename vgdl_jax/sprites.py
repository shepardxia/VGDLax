import jax
import jax.numpy as jnp
from vgdl_jax.state import GameState

# UP, DOWN, LEFT, RIGHT
DIRECTION_DELTAS = jnp.array([[-1, 0], [1, 0], [0, -1], [0, 1]], dtype=jnp.float32)


# ── Shared helpers ─────────────────────────────────────────────────────


def prefix_sum_allocate(alive_mask, source_mask):
    """Allocate dead slots to sources using prefix-sum.

    Args:
        alive_mask: [max_n] bool — current alive mask of the target type
        source_mask: [N] bool — which sources want to spawn (N may differ from max_n)

    Returns:
        (should_fill, src_indices):
            should_fill: [max_n] bool — which target slots to fill
            src_indices: [max_n] int — which source maps to each target slot
    """
    n_spawns = source_mask.sum()
    available = ~alive_mask
    slot_rank = jnp.cumsum(available)
    should_fill = available & (slot_rank <= n_spawns)
    source_order = jnp.argsort(~source_mask)
    src_indices = source_order[jnp.clip(slot_rank - 1, 0, source_mask.shape[0] - 1)]
    return should_fill, src_indices


def _move_with_cooldown(state, type_idx, cooldown):
    """Apply cooldown-gated movement along orientation.

    Returns:
        (new_pos, new_timers, can_move)
    """
    can_move = (state.cooldown_timers[type_idx] >= cooldown) & state.alive[type_idx]
    delta = state.orientations[type_idx]
    speed = state.speeds[type_idx]
    new_pos = state.positions[type_idx] + delta * speed[:, None] * can_move[:, None]
    new_timers = jnp.where(can_move, 0, state.cooldown_timers[type_idx])
    return new_pos, new_timers, can_move


# ── NPC movement updates ──────────────────────────────────────────────


def update_missile(state: GameState, type_idx, cooldown):
    """Move along fixed orientation each tick (if cooldown met and alive)."""
    new_pos, new_timers, _ = _move_with_cooldown(state, type_idx, cooldown)
    return state.replace(
        positions=state.positions.at[type_idx].set(new_pos),
        cooldown_timers=state.cooldown_timers.at[type_idx].set(new_timers),
    )


def update_erratic_missile(state: GameState, type_idx, cooldown, prob):
    """Missile that randomly changes direction with probability `prob` each tick."""
    rng, key_move, key_dir = jax.random.split(state.rng, 3)
    max_n = state.alive.shape[1]

    # Move along current orientation (same as missile)
    new_pos, new_timers, _ = _move_with_cooldown(state, type_idx, cooldown)

    # Randomly change direction with probability `prob`
    should_change = (jax.random.uniform(key_move, (max_n,)) < prob) & state.alive[type_idx]
    dir_indices = jax.random.randint(key_dir, (max_n,), 0, 4)
    random_ori = DIRECTION_DELTAS[dir_indices]
    new_ori = jnp.where(should_change[:, None], random_ori, state.orientations[type_idx])

    return state.replace(
        positions=state.positions.at[type_idx].set(new_pos),
        cooldown_timers=state.cooldown_timers.at[type_idx].set(new_timers),
        orientations=state.orientations.at[type_idx].set(new_ori),
        rng=rng,
    )


def update_random_npc(state: GameState, type_idx, cooldown):
    """Pick a random direction each move."""
    rng, key = jax.random.split(state.rng)
    can_move = (state.cooldown_timers[type_idx] >= cooldown) & state.alive[type_idx]
    max_n = state.alive.shape[1]
    # Random direction per instance
    dir_indices = jax.random.randint(key, (max_n,), 0, 4)
    deltas = DIRECTION_DELTAS[dir_indices]  # [max_n, 2]
    speed = state.speeds[type_idx]
    new_pos = state.positions[type_idx] + deltas * speed[:, None] * can_move[:, None]
    new_timers = jnp.where(can_move, 0, state.cooldown_timers[type_idx])
    return state.replace(
        positions=state.positions.at[type_idx].set(new_pos),
        cooldown_timers=state.cooldown_timers.at[type_idx].set(new_timers),
        rng=rng,
    )


def _manhattan_distance_field(target_pos, target_alive, height, width):
    """Compute Manhattan distance to nearest alive target for every grid cell.

    Uses iterative relaxation: O(H*W*(H+W)) total work, O(H+W) depth.
    Returns [H, W] int32 distance field.
    """
    INF = jnp.int32(height + width)
    # Initialize: 0 at alive target cells, INF elsewhere
    grid = jnp.full((height, width), INF, dtype=jnp.int32)
    itarget_pos = target_pos.astype(jnp.int32)
    in_bounds = (
        (itarget_pos[:, 0] >= 0) & (itarget_pos[:, 0] < height) &
        (itarget_pos[:, 1] >= 0) & (itarget_pos[:, 1] < width)
    )
    effective = target_alive & in_bounds
    r = jnp.clip(itarget_pos[:, 0], 0, height - 1)
    c = jnp.clip(itarget_pos[:, 1], 0, width - 1)
    grid = grid.at[r, c].min(jnp.where(effective, jnp.int32(0), INF))

    def relax(_, dist):
        up = jnp.concatenate([jnp.full((1, width), INF, jnp.int32),
                              dist[:-1]], axis=0) + 1
        down = jnp.concatenate([dist[1:],
                                jnp.full((1, width), INF, jnp.int32)], axis=0) + 1
        left = jnp.concatenate([jnp.full((height, 1), INF, jnp.int32),
                                dist[:, :-1]], axis=1) + 1
        right = jnp.concatenate([dist[:, 1:],
                                 jnp.full((height, 1), INF, jnp.int32)], axis=1) + 1
        return jnp.minimum(dist, jnp.minimum(
            jnp.minimum(up, down), jnp.minimum(left, right)))

    return jax.lax.fori_loop(0, height + width, relax, grid)


def update_chaser(state: GameState, type_idx, target_type_idx, cooldown,
                  fleeing=False, height=0, width=0):
    """Move toward (or away from) nearest target using grid distance field. O(H*W + N)."""
    rng, key = jax.random.split(state.rng)
    can_move = (state.cooldown_timers[type_idx] >= cooldown) & state.alive[type_idx]

    chaser_pos = state.positions[type_idx].astype(jnp.int32)  # [max_n, 2]
    target_pos = state.positions[target_type_idx]              # [max_n, 2]
    target_alive = state.alive[target_type_idx]     # [max_n]
    any_target_alive = jnp.any(target_alive)

    # Distance field: [H, W] Manhattan distance to nearest alive target
    dist_field = _manhattan_distance_field(target_pos, target_alive, height, width)

    # For each chaser, look up distance at each neighbor direction
    r = jnp.clip(chaser_pos[:, 0], 0, height - 1)
    c = jnp.clip(chaser_pos[:, 1], 0, width - 1)
    INF = jnp.int32(height + width)
    d_up    = jnp.where(r > 0,          dist_field[jnp.clip(r - 1, 0, height - 1), c], INF)
    d_down  = jnp.where(r < height - 1, dist_field[jnp.clip(r + 1, 0, height - 1), c], INF)
    d_left  = jnp.where(c > 0,          dist_field[r, jnp.clip(c - 1, 0, width - 1)], INF)
    d_right = jnp.where(c < width - 1,  dist_field[r, jnp.clip(c + 1, 0, width - 1)], INF)

    neighbor_dists = jnp.stack([d_up, d_down, d_left, d_right], axis=-1)  # [max_n, 4]
    if fleeing:
        best_dir = jnp.argmax(neighbor_dists, axis=-1)
    else:
        best_dir = jnp.argmin(neighbor_dists, axis=-1)
    delta = DIRECTION_DELTAS[best_dir]

    # If no targets alive, pick random direction
    rand_dirs = jax.random.randint(key, (chaser_pos.shape[0],), 0, 4)
    rand_delta = DIRECTION_DELTAS[rand_dirs]
    delta = jnp.where(any_target_alive, delta, rand_delta)

    speed = state.speeds[type_idx]  # [max_n] float32
    new_pos = state.positions[type_idx] + delta * speed[:, None] * can_move[:, None]
    new_timers = jnp.where(can_move, 0, state.cooldown_timers[type_idx])
    return state.replace(
        positions=state.positions.at[type_idx].set(new_pos),
        cooldown_timers=state.cooldown_timers.at[type_idx].set(new_timers),
        rng=rng,
    )


def spawn_sprite(state: GameState, spawner_type, spawner_idx, target_type,
                 orientation, speed):
    """Create a new sprite of target_type at the spawner's position."""
    pos = state.positions[spawner_type, spawner_idx]
    available = ~state.alive[target_type]
    slot = jnp.argmax(available)
    has_slot = available[slot]
    state = state.replace(
        alive=state.alive.at[target_type, slot].set(has_slot),
        positions=state.positions.at[target_type, slot].set(pos),
        orientations=state.orientations.at[target_type, slot].set(orientation),
        speeds=state.speeds.at[target_type, slot].set(speed),
        ages=state.ages.at[target_type, slot].set(0),
        cooldown_timers=state.cooldown_timers.at[target_type, slot].set(0),
    )
    return state


def update_spawn_point(state: GameState, type_idx, cooldown, prob, total,
                       target_type, target_orientation, target_speed):
    """Conditionally spawn sprites — fully vectorized via prefix-sum slot allocation."""
    rng, key = jax.random.split(state.rng)
    max_n = state.alive.shape[1]

    # Vectorized spawn decision
    # Use exact match (==) instead of (>=) to match py-vgdl's
    # `game.time % cooldown == 0` semantics: spawners only get one
    # chance per cooldown cycle, not retries every tick after eligible.
    is_alive = state.alive[type_idx]
    timer_ready = state.cooldown_timers[type_idx] == cooldown
    under_total = (total <= 0) | (state.spawn_counts[type_idx] < total)
    rand_ok = jax.random.uniform(key, (max_n,)) < prob
    should_spawn = is_alive & timer_ready & under_total & rand_ok

    # Parallel slot allocation in target type
    should_fill, src_idx = prefix_sum_allocate(state.alive[target_type], should_spawn)
    src_pos = state.positions[type_idx][src_idx]

    state = state.replace(
        alive=state.alive.at[target_type].set(
            state.alive[target_type] | should_fill),
        positions=state.positions.at[target_type].set(
            jnp.where(should_fill[:, None], src_pos,
                      state.positions[target_type])),
        orientations=state.orientations.at[target_type].set(
            jnp.where(should_fill[:, None], target_orientation,
                      state.orientations[target_type])),
        speeds=state.speeds.at[target_type].set(
            jnp.where(should_fill, target_speed,
                      state.speeds[target_type])),
        ages=state.ages.at[target_type].set(
            jnp.where(should_fill, 0, state.ages[target_type])),
        cooldown_timers=state.cooldown_timers.at[target_type].set(
            jnp.where(should_fill, 0, state.cooldown_timers[target_type])),
        rng=rng,
    )

    # Update spawn counts — only for spawners that actually got a slot
    n_filled = should_fill.sum()
    spawn_rank = jnp.cumsum(should_spawn)
    actually_spawned = should_spawn & (spawn_rank <= n_filled)
    new_counts = state.spawn_counts[type_idx] + actually_spawned.astype(jnp.int32)
    state = state.replace(
        spawn_counts=state.spawn_counts.at[type_idx].set(new_counts))

    # Reset cooldown timers for all spawners that attempted (timer_ready),
    # not just those that succeeded. Matches py-vgdl's once-per-cycle semantics.
    attempted = is_alive & timer_ready & under_total
    new_timers = jnp.where(attempted, 0, state.cooldown_timers[type_idx])
    state = state.replace(
        cooldown_timers=state.cooldown_timers.at[type_idx].set(new_timers))

    # Kill spawners that reached total
    total_reached = (total > 0) & (new_counts >= total)
    state = state.replace(
        alive=state.alive.at[type_idx].set(
            state.alive[type_idx] & ~(total_reached & actually_spawned)))

    return state


def update_spreader(state: GameState, type_idx, spreadprob):
    """Spreader: at age==2, replicate to 4 adjacent cells with probability `spreadprob` each."""
    rng, key = jax.random.split(state.rng)
    max_n = state.alive.shape[1]

    is_alive = state.alive[type_idx]
    ages = state.ages[type_idx]
    should_spread = is_alive & (ages == 2)

    # For each spreading sprite, try 4 directions
    # Random gate per sprite per direction
    rng, key_rand = jax.random.split(rng)
    rand_vals = jax.random.uniform(key_rand, (max_n, 4))
    spread_gates = rand_vals < spreadprob  # [max_n, 4]

    # Compute neighbor positions for all spreaders
    pos = state.positions[type_idx]  # [max_n, 2]
    # DIRECTION_DELTAS: UP, DOWN, LEFT, RIGHT
    neighbor_pos = pos[:, None, :] + DIRECTION_DELTAS[None, :, :]  # [max_n, 4, 2]

    # Create flat mask of which (sprite, direction) pairs should spawn
    spawn_mask = should_spread[:, None] & spread_gates  # [max_n, 4]
    flat_mask = spawn_mask.reshape(-1)  # [max_n * 4]
    flat_pos = neighbor_pos.reshape(-1, 2)  # [max_n * 4, 2]

    # Prefix-sum slot allocation
    should_fill, src_idx = prefix_sum_allocate(state.alive[type_idx], flat_mask)
    src_pos = flat_pos[src_idx]

    state = state.replace(
        alive=state.alive.at[type_idx].set(
            state.alive[type_idx] | should_fill),
        positions=state.positions.at[type_idx].set(
            jnp.where(should_fill[:, None], src_pos,
                      state.positions[type_idx])),
        ages=state.ages.at[type_idx].set(
            jnp.where(should_fill, 0, state.ages[type_idx])),
        rng=rng,
    )
    return state


def update_random_inertial(state: GameState, type_idx, mass, strength):
    """RandomInertial: ContinuousPhysics NPC, random force direction each tick.

    velocity += (random_direction * strength) / mass
    position += velocity
    orientation = velocity direction
    """
    rng, key = jax.random.split(state.rng)
    max_n = state.alive.shape[1]

    dir_indices = jax.random.randint(key, (max_n,), 0, 4)
    force = DIRECTION_DELTAS[dir_indices] * strength  # [max_n, 2]

    vel = state.velocities[type_idx]
    new_vel = vel + force / mass
    is_alive = state.alive[type_idx]
    # Only update alive sprites
    new_vel = jnp.where(is_alive[:, None], new_vel, vel)

    new_pos = state.positions[type_idx] + new_vel * is_alive[:, None]

    # Orientation from velocity
    speed = jnp.sqrt(jnp.sum(new_vel ** 2, axis=-1, keepdims=True))
    new_ori = jnp.where(
        (speed > 1e-6) & is_alive[:, None],
        new_vel / speed,
        state.orientations[type_idx])

    return state.replace(
        positions=state.positions.at[type_idx].set(new_pos),
        velocities=state.velocities.at[type_idx].set(new_vel),
        orientations=state.orientations.at[type_idx].set(new_ori),
        rng=rng,
    )


def update_walk_jumper(state: GameState, type_idx, prob, strength, gravity, mass):
    """WalkJumper NPC: horizontal walker with random upward jumps under gravity.

    Moves horizontally in orientation direction each tick.
    With probability (1-prob), applies upward velocity impulse when grounded.
    Gravity pulls down every tick.
    """
    alive = state.alive[type_idx]  # (max_n,)
    n = alive.shape[0]
    alive_f = alive.astype(jnp.float32)

    vel = state.velocities[type_idx]  # (max_n, 2)
    pf = state.passive_forces[type_idx]  # (max_n, 2)

    # Grounded: passive_forces row == 0 means wallStop zeroed it last frame
    grounded = (pf[:, 0] == 0.0)

    # Random jump: py-vgdl uses `prob < random()` → jump probability = 1-prob
    rng, key = jax.random.split(state.rng)
    rand_vals = jax.random.uniform(key, (n,))
    wants_jump = (rand_vals > prob) & grounded & alive

    # Horizontal direction from orientation col component
    h_dir = state.orientations[type_idx, :, 1]

    # Active forces
    active_row = jnp.where(wants_jump, -strength, 0.0)
    active_col = h_dir * strength * alive_f

    # Friction: horizontal friction when grounded (decelerates to allow jump direction to dominate)
    friction_col = jnp.where(grounded, -vel[:, 1] / mass, 0.0)

    # Velocity update
    new_vel_row = vel[:, 0] + active_row / mass + gravity
    new_vel_col = vel[:, 1] + (active_col + friction_col) / mass
    new_vel = jnp.stack([new_vel_row, new_vel_col], axis=-1)

    # Position update (only alive sprites move)
    new_pos = state.positions[type_idx] + new_vel * alive_f[:, None]

    # Reset passive forces to gravity (wallStop will zero on landing)
    new_pf_row = jnp.where(alive, gravity * mass, pf[:, 0])
    new_pf = jnp.stack([new_pf_row, pf[:, 1]], axis=-1)

    return state.replace(
        positions=state.positions.at[type_idx].set(new_pos),
        velocities=state.velocities.at[type_idx].set(new_vel),
        passive_forces=state.passive_forces.at[type_idx].set(new_pf),
        rng=rng,
    )


# ── Continuous physics avatar updates ─────────────────────────────────


def update_inertial_avatar(state: GameState, action, avatar_type, n_move,
                           mass, strength):
    """InertialAvatar: ContinuousPhysics, no gravity. Input = force direction.

    velocity += (direction * strength) / mass
    position += velocity
    orientation = velocity direction (for rendering)
    """
    is_move = action < n_move
    move_idx = jnp.clip(action, 0, 3)
    force = jax.lax.cond(
        is_move,
        lambda: DIRECTION_DELTAS[move_idx] * strength,
        lambda: jnp.array([0.0, 0.0], dtype=jnp.float32))

    vel = state.velocities[avatar_type, 0]
    new_vel = vel + force / mass
    new_pos = state.positions[avatar_type, 0] + new_vel

    # Orientation from velocity (if nonzero)
    speed = jnp.sqrt(jnp.sum(new_vel ** 2))
    new_ori = jnp.where(speed > 1e-6, new_vel / speed,
                        state.orientations[avatar_type, 0])

    return state.replace(
        positions=state.positions.at[avatar_type, 0].set(new_pos),
        velocities=state.velocities.at[avatar_type, 0].set(new_vel),
        orientations=state.orientations.at[avatar_type, 0].set(new_ori),
    )


def update_mario_avatar(state: GameState, action, avatar_type,
                        mass, strength, jump_strength, gravity,
                        airsteering):
    """MarioAvatar: GravityPhysics. 6-action space.

    Actions: LEFT=0, RIGHT=1, JUMP=2, JUMP_LEFT=3, JUMP_RIGHT=4, NOOP=5.

    Coordinate system: (row, col) where +row = down.
    Gravity = (+gravity_val, 0) in row direction.
    Jump = negative row velocity (upward).
    """
    # Decode action → (horizontal_dir, wants_jump)
    # LEFT=0: h=-1, RIGHT=1: h=+1, JUMP=2: h=0, JUMP_LEFT=3: h=-1, JUMP_RIGHT=4: h=+1, NOOP=5: h=0
    h = jnp.where(
        (action == 0) | (action == 3), -1.0,
        jnp.where((action == 1) | (action == 4), 1.0, 0.0))
    wants_jump = (action == 2) | (action == 3) | (action == 4)

    vel = state.velocities[avatar_type, 0]
    pf = state.passive_forces[avatar_type, 0]

    # Grounded: passive_forces[row] == 0 means wallStop zeroed it last frame
    grounded = (pf[0] == 0.0)

    # Active force computation (5 cases)
    # Case 1: grounded + jump → (-jump_strength, h * strength)
    # Case 2: airborne + airsteering → (0, h * strength)
    # Case 3: airborne + no steering → (0, 0)
    # Case 4: grounded + horizontal → (0, h * strength)
    # Case 5: else → (0, 0)
    active_row = jnp.where(grounded & wants_jump, -jump_strength, 0.0)
    active_col = jnp.where(
        grounded | airsteering, h * strength, 0.0)
    active_force = jnp.array([active_row, active_col])

    # Friction: on ground or with airsteering, apply horizontal friction
    friction_col = jnp.where(
        grounded | airsteering, -vel[1] / mass, 0.0)
    friction_force = jnp.array([0.0, friction_col])

    # Velocity update
    new_vel = vel + (active_force + friction_force) / mass

    # Apply gravity
    new_vel = new_vel.at[0].add(gravity)

    # Position update
    new_pos = state.positions[avatar_type, 0] + new_vel

    # Reset passive_forces to gravity (wallStop will zero on landing)
    new_pf = jnp.array([gravity * mass, 0.0])

    # Orientation: face movement direction (horizontal only for Mario)
    new_ori = jnp.where(
        jnp.abs(h) > 0.0,
        jnp.array([0.0, h]),
        state.orientations[avatar_type, 0])

    return state.replace(
        positions=state.positions.at[avatar_type, 0].set(new_pos),
        velocities=state.velocities.at[avatar_type, 0].set(new_vel),
        passive_forces=state.passive_forces.at[avatar_type, 0].set(new_pf),
        orientations=state.orientations.at[avatar_type, 0].set(new_ori),
    )
